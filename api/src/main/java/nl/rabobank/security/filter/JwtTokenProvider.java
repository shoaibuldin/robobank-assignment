package nl.rabobank.security.filter;import io.jsonwebtoken.*;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.Authentication;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.User;import org.springframework.stereotype.Component;import java.util.Arrays;import java.util.Collection;import java.util.Date;import java.util.stream.Collectors;@Componentpublic class JwtTokenProvider {    private static final Logger logger = LoggerFactory.getLogger(JwtTokenProvider.class);    private static final String INVALID_JWT_TOKEN = "Invalid JWT token.";    private final String AUTHORITIES_KEY = "auth";    @Value("${app.jwtSecret}")    private String jwtSecret;    @Value("${app.jwtExpirationInMs}")    private int jwtExpirationInMs;    public String createToken(Authentication authentication) {        String authorities = authentication.getAuthorities().stream().map(GrantedAuthority::getAuthority).collect(Collectors.joining(","));        long now = (new Date()).getTime();        Date validity = new Date(now + jwtExpirationInMs);        return Jwts.builder()                .setSubject(authentication.getName())                .claim(AUTHORITIES_KEY, authorities)                .setIssuedAt(new Date())                .setExpiration(validity)                .signWith(SignatureAlgorithm.HS512, jwtSecret)                .compact();    }    public Authentication getAuthentication(String token) {        Claims claims = Jwts.parser()                .setSigningKey(jwtSecret)                .parseClaimsJws(token)                .getBody();        Collection<? extends GrantedAuthority> authorities = Arrays                .stream(claims.get(AUTHORITIES_KEY).toString().split(","))                .filter(auth -> !auth.trim().isEmpty())                .map(SimpleGrantedAuthority::new)                .collect(Collectors.toList());        User principal = new User(claims.getSubject(), "", authorities);        return new UsernamePasswordAuthenticationToken(principal, token, authorities);    }    public boolean validateToken(String authToken) {        try {            //jwtParser.parseClaimsJws(authToken);            Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(authToken);            return true;        } catch (ExpiredJwtException | MalformedJwtException | SignatureException | UnsupportedJwtException e) {            logger.trace(INVALID_JWT_TOKEN, e);        } catch (IllegalArgumentException e) {            logger.error("Token validation error {}", e.getMessage());        }        return false;    }}